#include <stdio.h>
#include "DES.h"
#include "type.h"
/*DES:Data Encrytion Standard
* 对称密码
* 分组长度：64位（8字节）
* 秘钥长度：64位（8字节）
* 每组密文长度：64位（8字节）
*/

u8 KEY[17][8];//子秘钥，每字节低7位有效一行即一组子秘钥
u32 DES_C[17];//存放子秘钥前28位（从左往右），最后4位补0
u32 DES_D[17];//存放子秘钥后28位（从左往右），最后4位补0
u32 DES_L[17];//存放IP变换前32位（从左往右）
u32 DES_R[17];//存放IP变换后32位（从左往右）

/*IP置换规则*/
//static const u8 IP[64]=
//	{58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4,
//	 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8,
//	 57, 49, 41, 33, 25, 17, 9,  1, 59, 51, 43, 35, 27, 19, 11, 3,
//	 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7};
static const u8 IP[64]=
	{57, 49, 41, 33, 25, 17, 9,  1, 59, 51, 43, 35, 27, 19, 11, 3,
	 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7,
	 56, 48, 40, 32, 24, 16, 8,  0, 58, 50, 42, 34, 26, 18, 10, 2,
	 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6};

/*秘钥置换规则*/
//static const u8 KP[64]=
//	{57, 49, 41, 33, 25, 17, 9,  0, 1,  58, 50, 42, 34, 26, 18, 0,
//	 10, 2,  59, 51, 43, 35, 27, 0, 19, 11, 3,  60, 52, 44, 36, 0,
//	 63, 55, 47, 39, 31, 23, 15, 0, 7,  62, 54, 46, 38, 30, 22, 0,
//	 14, 6,  61, 53, 45, 37, 29, 0, 21, 13, 5,  28, 20, 12, 4,	0};
static const u8 KP[56]=
	{56, 48, 40, 32, 24, 16, 8,    0,  57, 49, 41, 33, 25, 17, 
	 9,  1,  58, 50, 42, 34, 26,   18, 10, 2,  59, 51, 43, 35, 
	 62, 54, 46, 38, 30, 22, 14,   6,  61, 53, 45, 37, 29, 21, 
	 13, 5,  60, 52, 44, 36, 28,   20, 12, 4,  27, 19, 11, 3,};

/*求取子秘钥时左移位数*/
static const u8 Left_Shift[17]={0,1,1,2,2,2,2,2,2,  1,2,2,2,2,2,2,1};
/*秘钥压缩*/
//static const u8 Compress_Table[48]=
//	{14,    17,   11,    24,     1,    5,
//      3,    28,   15,     6,    21,   10,
//     23,    19,   12,     4,    26,    8,
//     16,     7,   27,    20,    13,    2,
//     41,    52,   31,    37,    47,   55,
//     30,    40,   51,    45,    33,   48,
//     44,    49,   39,    56,    34,   53,
//     46,    42,   50,    36,    29,   32};
static const u8 Compress_Table[48]=
	{13,    16,   10,    23,     0,    4,
      2,    27,   14,     5,    20,    9,
     22,    18,   11,     3,    25,    7,
     15,     6,   26,    19,    12,    1,
     40,    51,   30,    36,    46,   54,
     29,    39,   50,    44,    32,   47,
     43,    48,   38,    55,    33,   52,
     45,    41,   49,    35,    28,   31};

/*E函数用到的矩阵*/
//static const u8 E_Bit_Selection_Table[48]=
//	{32, 1,  2,  3,  4,  5,
//	 4,  5,  6,  7,  8,  9,
//	 8,  9,  10, 11, 12, 13,
//	 12, 13, 14, 15, 16, 17,
//	 16, 17, 18, 19, 20, 21,
//	 20, 21, 22, 23, 24, 25,
//	 24, 25, 26, 27, 28, 29,
//	 28, 29, 30, 31, 32, 1};
static const u8 E_Bit_Selection_Table[48]=
	{31, 0,  1,  2,  3,  4,
	 3,  4,  5,  6,  7,  8,
	 7,  8,  9,  10, 11, 12,
	 11, 12, 13, 14, 15, 16,
	 15, 16, 17, 18, 19, 20,
	 19, 20, 21, 22, 23, 24,
	 23, 24, 25, 26, 27, 28,
	 27, 28, 29, 30, 31, 0};

/*************S盒**************************/
static const u8 S_Table[8][64] = 
	{14,  4,  13,  1,   2, 15,  11,  8,   3, 10,   6, 12,   5,  9,   0,  7,
      0, 15,   7,  4,  14,  2,  13,  1,  10,  6,  12, 11,   9,  5,   3,  8,
      4,  1,  14,  8,  13,  6,   2, 11,  15, 12,   9,  7,   3, 10,   5,  0,
     15, 12,   8,  2,   4,  9,   1,  7,   5, 11,   3, 14,  10,  0,   6, 13,

	 15,  1,   8, 14,   6, 11,   3,  4,   9,  7,   2, 13,  12,  0,   5, 10,
      3, 13,   4,  7,  15,  2,   8, 14,  12,  0,   1, 10,   6,  9,  11,  5,
      0, 14,   7, 11,  10,  4,  13,  1,   5,  8,  12,  6,   9,  3,   2, 15,
     13,  8,  10,  1,   3, 15,   4,  2,  11,  6,   7, 12,   0,  5,  14,  9,

	 10,  0,   9, 14,   6,  3,  15,  5,   1, 13,  12,  7,  11,  4,   2,  8,
     13,  7,   0,  9,   3,  4,   6, 10,   2,  8,   5, 14,  12, 11,  15,  1,
     13,  6,   4,  9,   8, 15,   3,  0,  11,  1,   2, 12,   5, 10,  14,  7,
      1, 10,  13,  0,   6,  9,   8,  7,   4, 15,  14,  3,  11,  5,   2, 12,

	  7, 13,  14,  3,   0,  6,   9, 10,   1,  2,   8,  5,  11, 12,   4, 15,
     13,  8,  11,  5,   6, 15,   0,  3,   4,  7,   2, 12,   1, 10,  14,  9,
     10,  6,   9,  0,  12, 11,   7, 13,  15,  1,   3, 14,   5,  2,   8,  4,
      3, 15,   0,  6,  10,  1,  13,  8,   9,  4,   5, 11,  12,  7,   2, 14,

	  2, 12,   4,  1,   7, 10,  11,  6,   8,  5,   3, 15,  13,  0,  14,  9,
     14, 11,   2, 12,   4,  7,  13,  1,   5,  0,  15, 10,   3,  9,   8,  6,
      4,  2,   1, 11,  10, 13,   7,  8,  15,  9,  12,  5,   6,  3,   0, 14,
     11,  8,  12,  7,   1, 14,   2, 13,   6, 15,   0,  9,  10,  4,   5,  3,

	 12,  1,  10, 15,   9,  2,   6,  8,   0, 13,   3,  4,  14,  7,   5, 11,
     10, 15,   4,  2,   7, 12,   9,  5,   6,  1,  13, 14,   0, 11,   3,  8,
      9, 14,  15,  5,   2,  8,  12,  3,   7,  0,   4, 10,   1, 13,  11,  6,
      4,  3,   2, 12,   9,  5,  15, 10,  11, 14,   1,  7,   6,  0,   8, 13,

	  4, 11,   2, 14,  15,  0,   8, 13,   3, 12,   9,  7,   5, 10,   6,  1,
     13,  0,  11,  7,   4,  9,   1, 10,  14,  3,   5, 12,   2, 15,   8,  6,
      1,  4,  11, 13,  12,  3,   7, 14,  10, 15,   6,  8,   0,  5,   9,  2,
      6, 11,  13,  8,   1,  4,  10,  7,   9,  5,   0, 15,  14,  2,   3, 12,

	 13,  2,   8,  4,   6, 15,  11,  1,  10,  9,   3, 14,   5,  0,  12,  7,
      1, 15,  13,  8,  10,  3,   7,  4,  12,  5,   6, 11,   0, 14,   9,  2,
      7, 11,   4,  1,   9, 12,  14,  2,   0,  6,  10, 13,  15,  3,   5,  8,
      2,  1,  14,  7,   4, 10,   8, 13,  15, 12,   9,  0,   3,  5,   6, 11};

/*S盒输出后再变换的矩阵*/
//static const u8 P_Table[32]=
//	{ 16,   7,  20,  21,    29,  12,  28,  17,
//       1,  15,  23,  26,     5,  18,  31,  10,
//       2,   8,  24,  14,    32,  27,   3,   9,
//      19,  13,  30,   6,    22,  11,   4,  25};
static const u8 P_Table[32]=
	{ 15,   6,  19,  20,    28,  11,  27,  16,
       0,  14,  22,  25,     4,  17,  30,   9,
       1,   7,  23,  13,    31,  26,   2,   8,
      18,  12,  29,   5,    21,  10,   3,  24};

/*最终变换用到的矩阵*/
//static const u8 IP_1[64]=
//	{ 40,     8,   48,    16,    56,   24,    64,   32,
//      39,     7,   47,    15,    55,   23,    63,   31,
//      38,     6,   46,    14,    54,   22,    62,   30,
//      37,     5,   45,    13,    53,   21,    61,   29,
//      36,     4,   44,    12,    52,   20,    60,   28,
//      35,     3,   43,    11,    51,   19,    59,   27,
//      34,     2,   42,    10,    50,   18,    58,   26,
//      33,     1,   41,     9,    49,   17,    57,   25};
static const u8 IP_1[64]=
	{ 39,     7,   47,    15,    55,   23,    63,   31,
      38,     6,   46,    14,    54,   22,    62,   30,
      37,     5,   45,    13,    53,   21,    61,   29,
      36,     4,   44,    12,    52,   20,    60,   28,
      35,     3,   43,    11,    51,   19,    59,   27,
      34,     2,   42,    10,    50,   18,    58,   26,
      33,     1,   41,     9,    49,   17,    57,   25,
      32,     0,   40,     8,    48,   16,    56,   24};
/*************************************************
*function name:KeyExchange
*function:秘钥置换
*input:	key-秘钥,8字节(每字节低7位有效)
*output:KEY-子秘钥
**************************************************/
//static void KeyExchange(u8 *key,u8 num,u8 *C0, u8 *D0)
static void KeyExchange(u8 *key)
{
	u8 i,j;
	u8 temp;//存放临时数据
	
	for(i=0;i<56;i++)//64位原始秘钥置换，得到初始子KEY0（每字节低7位有效）
	{
		j = i/7;
		KEY[0][j] |= (key[KP[i]/8]>>(7-KP[i]%8))&0x01;
		if((i%7) != 6)
			KEY[0][j] = KEY[0][j]<<1;//左移，直到填满低7位
	}

	for(i=1;i<=DES_ENCRYPT_NUM;i++)//生成其他子秘钥
	{
		for(j=0;j<4;j++)//循环左移
		{
			if(j!=3)//将最高位保存在临时变量中
				temp = KEY[i-1][j+1]>>(7-Left_Shift[i]);//左移获取移出去的位
			else
				temp = KEY[i-1][0]>>(7-Left_Shift[i]);
			KEY[i][j]=((KEY[i-1][j]<<Left_Shift[i])|temp)&0x7f;//低7位有效
		}
		for(j=4;j<8;j++)//循环左移
		{
			if(j!=7)//将最高位保存在临时变量中
				temp = KEY[i-1][j+1]>>(7-Left_Shift[i]);//左移获取移出去的位
			else
				temp = KEY[i-1][4]>>(7-Left_Shift[i]);
			KEY[i][j]=((KEY[i-1][j]<<Left_Shift[i])|temp)&0x7f;//低7位有效
		}
	}

}
/*************************************************
*function name:KeyCompress
*function:秘钥压缩
*input:	KEY-子秘钥（低7位有效）
*output:KEY-子秘钥（低6位有效）
**************************************************/
static void KeyCompress()
{
	u8 i,j,k;
	u8 temp[8]={0};//存放临时数据
	for(i=1;i<=16;i++)//子秘钥每字节压缩成低6位有效
	{
		for(j=0;j<48;j++)
		{
			k = j/6;
			temp[k] |= (KEY[i][Compress_Table[j]/7] >> (6-Compress_Table[j]%7))&0x01;
			if((j%6) != 5)
				temp[k] = temp[k]<<1;//左移，直到填满低6位
		}
		for(j=0;j<8;j++)//压缩后的子秘钥赋值
		{
			KEY[i][j] = temp[j];
			temp[j] = 0;
		}
	}
}
/*************************************************
*function name:E
*function:E扩展置换，输入32位，扩展成48位，即8字节（每字节低6位有效）
*input:	Rn-输入32位数据
*output:RnExtend-返回8字节（每字节低6位有效）
**************************************************/
static void E(u32 Rn, u8 *RnExtend)
{
	u8 i,j;
	for(i=0;i<48;i++)
	{
		j = i/6;
		RnExtend[j] |= (Rn>>(31-E_Bit_Selection_Table[i]))&0x01;
		if((i%6) != 5)
			RnExtend[j] = RnExtend[j]<<1;//左移，直到低6位填满
	}
}
/*************************************************
*function name:S_Inverse
*function:S盒替换
*input:	data-低6位有效  S_Table-对应的S盒
*output:1字节数据，低4位有效
**************************************************/
static u8 S_Inverse(u8 data,const u8 *s_table)
{
	u8 row;
	u8 column;
	row = ((data&0x20)>>4)|(data&0x01);//行
	column = (data&0x1E)>>1;			//列
	return *(s_table+row*16+column);	//返回数据低4位有效
}
/*************************************************
*function name:f
*function:迭代函数
*input:	Rn-块区域右半部分，Cn-子秘钥左半部分（高24位有效），Dn-子秘钥右半部分(高24位有效)
*output:32位字
**************************************************/
//static u32 f(u32 Rn,u32 Kn)
static u32 f(u32 Rn,u8 *key)
{
	u8 RnExtend[8]={0};//存放E扩展出的8字节（每字节低6位有效）
	u8 temp[8]={0};//存放异或后的值
	u8 temp1[8]={0};
	u8 i,j;
	u32 value=0;//存放返回值

	E(Rn,RnExtend);//将32位Rn扩展成48位，即8字节（每字节低6位有效）
	for(i=0;i<8;i++)
	{
		temp[i] = key[i]^RnExtend[i];//Rn扩展值和压缩秘钥异或
		temp[i] = S_Inverse(temp[i], &(S_Table[i][0]));//异或后的值经S盒替换，返回值低4位有效
		//value |= (temp[i]&0x0f)<<(4*(7-i));
	}
	for(i=0;i<32;i++)//对S盒输出进行变换
	{
			j = i/4;
			temp1[j] |= (temp[P_Table[i]/4]>>(3-P_Table[i]%4))&0x01;
			if((i%4) != 3)
				temp1[j] = temp1[j]<<1;//左移，直到低4位填满
	}
	for(i=0;i<8;i++)//组合成32位返回值
		value |= (temp1[i]&0x0f)<<(4*(7-i));
	return value;
}

/*************************************************
*function name:IPExchange
*function:IP置换(Initial Permutation)
*input:	plaintext-明文
*output:L[i]-置换后左部分   R[i]-置换后右部分
**************************************************/
//static void IPExchange(u8 *plaintext,u32 *L0,u32 *R0)
static void IPExchange(u8 *plaintext)
{
	u8 i;
	u8 temp[8]={0};//临时存放置换后数据
	for(i=0;i<64;i++)
	{
		temp[i/8] |= (plaintext[IP[i]/8]>>(7-IP[i]%8))&0x01;
		if((i%8) != 7)
			temp[i/8] = temp[i/8]<<1;//左移，直到填满1字节
	}
	DES_L[0] = ((u32)temp[0]<<24)|((u32)temp[1]<<16)|((u32)temp[2]<<8)|((u32)temp[3]);
	DES_R[0] = ((u32)temp[4]<<24)|((u32)temp[5]<<16)|((u32)temp[6]<<8)|((u32)temp[7]);
	for(i=1;i<=DES_ENCRYPT_NUM;i++)
	{
		DES_L[i]=DES_R[i-1];
		DES_R[i]=DES_L[i-1]^f(DES_R[i-1],&KEY[i][0]);
	}
}

/*************************************************
*function name:DES
*function:通过秘钥将明文计算出密文
*input:	plaintext-明文，
*output:ciphertext-密文
*DES的秘钥有效位为56位，因为第8、16、24、32、48、56、64位是校验位
*使得每个密钥都有奇数个1
**************************************************/
void DES(u8 *plaintext,u8 *key, u8 *ciphertext)
{
	u8 i,j;
	KeyExchange(key);//扩展秘钥
	KeyCompress();	//压缩秘钥
	IPExchange(plaintext);//置换明文

	for(i=0;i<64;i++)//进行最后的置换，生成密文
	{
		j = IP_1[i]/8;//对应字节
		if(j<4)
			ciphertext[i/8] |= (u8)((DES_R[16]>>(31-IP_1[i]%32))&0x01);
		else
			ciphertext[i/8] |= (u8)((DES_L[16]>>(31-IP_1[i]%32))&0x01);
		if((i%8) != 7)
			ciphertext[i/8] = ciphertext[i/8]<<1;//左移，直到填满1字节
	}
}

